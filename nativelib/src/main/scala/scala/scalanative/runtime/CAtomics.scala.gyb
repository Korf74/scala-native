package scala.scalanative
package runtime

import scala.scalanative.native._
import scala.scalanative.runtime.Atomic._

abstract class CAtomic

%{
   classes = ['Byte', 'Short', 'Int', 'Long',
            'UnsignedByte', 'UnsignedShort', 'UnsignedInt',
             'UnsignedLong', 'Char', 'UnsignedChar', 'CSize']

   types = ['Byte', 'CShort', 'CInt', 'CLong',
            'Byte', 'CUnsignedShort', 'CUnsignedInt', 'CUnsignedLong',
            'CChar', 'CUnsignedChar', 'CSize']

   names = ['byte', 'short', 'int', 'long',
            'ubyte', 'ushort', 'uint', 'ulong',
            'char', 'uchar', 'csize']
}%

% for (C, T, N) in zip(classes, types, names):

%{
   default = '0' if N in ['int'] else ('\'a\'.asInstanceOf['+T+']' if N in ['char', 'uchar'] else '0.asInstanceOf['+T+']')
   cast = '' if N in ['byte', 'ubyte'] else '.cast[Ptr['+T+']]'
   castB = '' if N in ['byte', 'ubyte'] else '.cast[Ptr[Byte]]'
}%

class CAtomic${C}(default: ${T} = ${default}) extends CAtomic {

  private[this] val atm = Atomic.alloc(sizeof[${T}])${cast}
  init_${N}(atm, default)

  def load(): ${T} = load_${N}(atm)

  def store(value: ${T}): Unit = init_${N}(atm, value)

  def free(): Unit = Atomic.free(atm${castB})

  def compareAndSwapStrong(expected: ${T}, desired: ${T}): (Boolean, ${T}) = {
    val expectedPtr = stackalloc[${T}]
    !expectedPtr = expected

    if (compare_and_swap_strong_${N}(atm, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def compareAndSwapWeak(expected: ${T}, desired: ${T}): (Boolean, ${T}) = {
    val expectedPtr = stackalloc[${T}]
    !expectedPtr = expected

    if (compare_and_swap_weak_${N}(atm, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def addFetch(value: ${T}): ${T} = {
    fetchAdd(value)
    load()
  }

  def fetchAdd(value: ${T}): ${T} = atomic_add_${N}(atm, value)

  def subFetch(value: ${T}): ${T} = {
    fetchSub(value)
    load()
  }

  def fetchSub(value: ${T}): ${T} = atomic_sub_${N}(atm, value)

  def andFetch(value: ${T}): ${T} = {
    fetchAnd(value)
    load()
  }

  def fetchAnd(value: ${T}): ${T} = atomic_and_${N}(atm, value)

  def orFetch(value: ${T}): ${T} = {
    fetchOr(value)
    load()
  }

  def fetchOr(value: ${T}): ${T} = atomic_or_${N}(atm, value)

  def xorFetch(value: ${T}): ${T} = {
    fetchXor(value)
    load()
  }

  def fetchXor(value: ${T}): ${T} = atomic_xor_${N}(atm, value)

  override def toString: String = load().toString

}

object CAtomic${C} extends CAtomic {

  def apply(initValue: ${T}) = new CAtomic${C}(initValue)

  def apply() = new CAtomic${C}()

}

% end
class CAtomicRef extends CAtomic {

  private[this] var atm = 0.cast[Ptr[Ptr[Byte]]]

  def this(sz: CSize) = {
    this()
    atm = Atomic.alloc(sz).cast[Ptr[Ptr[Byte]]]
    init_ref(atm, 0.cast[Ptr[Byte]])
  }

  def this(sz: CSize, default: Ptr[Byte]) = {
    this(sz)
    init_ref(atm, default)
  }

  def load(): Ptr[Byte] = load_ref(atm)

  def store(value: Ptr[Byte]): Unit = init_ref(atm, value)

  def free(): Unit = Atomic.free(atm.cast[Ptr[Byte]])

  def compareAndSwapStrong(expected: Ptr[Byte], desired: Ptr[Byte]): (Boolean, Ptr[Byte]) = {
    val expectedPtr = stackalloc[Ptr[Byte]]
    !expectedPtr = expected

    if (compare_and_swap_strong_ref(atm, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def compareAndSwapWeak(expected: Ptr[Byte], desired: Ptr[Byte]): (Boolean, Ptr[Byte]) = {
    val expectedPtr = stackalloc[Ptr[Byte]]
    !expectedPtr = expected

    if (compare_and_swap_weak_ref(atm, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  override def toString: String = load().toString

}

object CAtomicRef extends CAtomic {

  def apply(sz: CSize, initValue: Ptr[Byte]) = new CAtomicRef(sz, initValue)

  def apply(sz: CSize) = new CAtomicRef(sz)

}

